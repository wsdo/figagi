{
	"title": "Python3 面向对象 | 菜鸟教程",
	"url": "https://www.runoob.com/python3/python3-class.html",
	"html": "菜鸟教程 -- 学的不仅是技术，更是梦想！\n首页 HTML CSS JAVASCRIPT VUE BOOTSTRAP NODEJS PYTHON3 PYTHON2 JAVA C C++ C# GO SQL LINUX JQUERY 本地书签\n Python 3 教程 \nPython3 教程\nPython3 简介\nPython3 环境搭建\nPython3 VScode\nPython3 基础语法\nPython3 基本数据类型\nPython3 数据类型转换\nPython3 解释器\nPython3 注释\nPython3 运算符\nPython3 数字(Number)\nPython3 字符串\nPython3 列表\nPython3 元组\nPython3 字典\nPython3 集合\nPython3 条件控制\nPython3 循环语句\nPython3 编程第一步\nPython3 推导式\nPython3 迭代器与生成器\nPython3 函数\nPython3 lambda\nPython3 数据结构\nPython3 模块\nPython3 输入和输出\nPython3 File\nPython3 OS\nPython3 错误和异常\n Python3 面向对象\nPython3 命名空间/作用域\nPython3 标准库概览\nPython3 实例\nPython 测验\n\n\nPython3 高级教程\nPython3 正则表达式\nPython3 CGI编程\nPython3 MySQL(mysql-connector)\nPython3 MySQL(PyMySQL)\nPython3 网络编程\nPython3 SMTP发送邮件\nPython3 多线程\nPython3 XML 解析\nPython3 JSON\nPython3 日期和时间\nPython3 内置函数\nPython3 MongoDB\nPython3 urllib\nPython uWSGI 安装配置\nPython3 pip\nPython3 operator\nPython math\nPython requests\nPython random\nPython 有用的资源\nPython AI 绘画\nPython statistics\n Python3 错误和异常\nPython3 命名空间/作用域 \nPython3 面向对象\n\nPython从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。\n\n如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。\n\n接下来我们先来简单的了解下面向对象的一些基本特征。\n\n面向对象技术简介\n类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。\n方法：类中定义的函数。\n类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。\n方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。\n局部变量：定义在方法中的变量，只作用于当前实例的类。\n实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。\n继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个（is-a）\"关系（例图，Dog是一个Animal）。\n实例化：创建一个类的实例，类的具体对象。\n对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。\n\n和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。\n\nPython中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。\n\n对象可以包含任意数量和类型的数据。\n\n类定义\n\n语法格式如下：\n\nclass ClassName:\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n\n类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。\n\n类对象\n\n类对象支持两种操作：属性引用和实例化。\n\n属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。\n\n类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:\n\n实例(Python 3.0+)\n#!/usr/bin/python3\n \nclass MyClass:\n    \"\"\"一个简单的类实例\"\"\"\n    i = 12345\n    def f(self):\n        return 'hello world'\n \n# 实例化类\nx = MyClass()\n \n# 访问类的属性和方法\nprint(\"MyClass 类的属性 i 为：\", x.i)\nprint(\"MyClass 类的方法 f 输出为：\", x.f())\n\n以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。\n\n执行以上程序输出结果为：\n\nMyClass 类的属性 i 为： 12345\nMyClass 类的方法 f 输出为： hello world\n\n类有一个名为 __init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样：\n\ndef __init__(self):\n    self.data = []\n\n类定义了 __init__() 方法，类的实例化操作会自动调用 __init__() 方法。如下实例化类 MyClass，对应的 __init__() 方法就会被调用:\n\nx = MyClass()\n\n当然， __init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。例如:\n\n实例(Python 3.0+)\n#!/usr/bin/python3\n \nclass Complex:\n    def __init__(self, realpart, imagpart):\n        self.r = realpart\n        self.i = imagpart\nx = Complex(3.0, -4.5)\nprint(x.r, x.i)   # 输出结果：3.0 -4.5\nself代表类的实例，而非类\n\n类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。\n\nclass Test:\n    def prt(self):\n        print(self)\n        print(self.__class__)\n \nt = Test()\nt.prt()\n\n以上实例执行结果为：\n\n<__main__.Test instance at 0x100771878>\n__main__.Test\n\n从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。\n\nself 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:\n\nclass Test:\n    def prt(runoob):\n        print(runoob)\n        print(runoob.__class__)\n \nt = Test()\nt.prt()\n\n以上实例执行结果为：\n\n<__main__.Test instance at 0x100771878>\n__main__.Test\n类的方法\n\n在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。\n\n实例(Python 3.0+)\n#!/usr/bin/python3\n \n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n    #定义构造方法\n    def __init__(self,n,a,w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n \n# 实例化类\np = people('runoob',10,30)\np.speak()\n\n执行以上程序输出结果为：\n\nrunoob 说: 我 10 岁。\n继承\n\nPython 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:\n\nclass DerivedClassName(BaseClassName):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n\n子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。\n\nBaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:\n\nclass DerivedClassName(modname.BaseClassName):\n实例(Python 3.0+)\n#!/usr/bin/python3\n \n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n    #定义构造方法\n    def __init__(self,n,a,w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n \n#单继承示例\nclass student(people):\n    grade = ''\n    def __init__(self,n,a,w,g):\n        #调用父类的构函\n        people.__init__(self,n,a,w)\n        self.grade = g\n    #覆写父类的方法\n    def speak(self):\n        print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade))\n \n \n \ns = student('ken',10,60,3)\ns.speak()\n\n执行以上程序输出结果为：\n\nken 说: 我 10 岁了，我在读 3 年级\n多继承\n\nPython同样有限的支持多继承形式。多继承的类定义形如下例:\n\nclass DerivedClassName(Base1, Base2, Base3):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n\n需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。\n\n实例(Python 3.0+)\n#!/usr/bin/python3\n \n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n    #定义构造方法\n    def __init__(self,n,a,w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n \n#单继承示例\nclass student(people):\n    grade = ''\n    def __init__(self,n,a,w,g):\n        #调用父类的构函\n        people.__init__(self,n,a,w)\n        self.grade = g\n    #覆写父类的方法\n    def speak(self):\n        print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade))\n \n#另一个类，多继承之前的准备\nclass speaker():\n    topic = ''\n    name = ''\n    def __init__(self,n,t):\n        self.name = n\n        self.topic = t\n    def speak(self):\n        print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic))\n \n#多继承\nclass sample(speaker,student):\n    a =''\n    def __init__(self,n,a,w,g,t):\n        student.__init__(self,n,a,w,g)\n        speaker.__init__(self,n,t)\n \ntest = sample(\"Tim\",25,80,4,\"Python\")\ntest.speak()   #方法名同，默认调用的是在括号中参数位置排前父类的方法\n\n执行以上程序输出结果为：\n\n我叫 Tim，我是一个演说家，我演讲的主题是 Python\n方法重写\n\n如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：\n\n实例(Python 3.0+)\n#!/usr/bin/python3\n \nclass Parent:        # 定义父类\n   def myMethod(self):\n      print ('调用父类方法')\n \nclass Child(Parent): # 定义子类\n   def myMethod(self):\n      print ('调用子类方法')\n \nc = Child()          # 子类实例\nc.myMethod()         # 子类调用重写方法\nsuper(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法\n\nsuper() 函数是用于调用父类(超类)的一个方法。\n\n执行以上程序输出结果为：\n\n调用子类方法\n调用父类方法\n\n更多文档：\n\nPython 子类继承父类构造函数说明\n\n类属性与方法\n类的私有属性\n\n__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。\n\n类的方法\n\n在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。\n\nself 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。\n\n类的私有方法\n\n__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。\n\n实例\n\n类的私有属性实例如下：\n\n实例(Python 3.0+)\n#!/usr/bin/python3\n \nclass JustCounter:\n    __secretCount = 0  # 私有变量\n    publicCount = 0    # 公开变量\n \n    def count(self):\n        self.__secretCount += 1\n        self.publicCount += 1\n        print (self.__secretCount)\n \ncounter = JustCounter()\ncounter.count()\ncounter.count()\nprint (counter.publicCount)\nprint (counter.__secretCount)  # 报错，实例不能访问私有变量\n\n执行以上程序输出结果为：\n\n1\n2\n2\nTraceback (most recent call last):\n  File \"test.py\", line 16, in <module>\n    print (counter.__secretCount)  # 报错，实例不能访问私有变量\nAttributeError: 'JustCounter' object has no attribute '__secretCount'\n\n类的私有方法实例如下：\n\n实例(Python 3.0+)\n#!/usr/bin/python3\n \nclass Site:\n    def __init__(self, name, url):\n        self.name = name       # public\n        self.__url = url   # private\n \n    def who(self):\n        print('name  : ', self.name)\n        print('url : ', self.__url)\n \n    def __foo(self):          # 私有方法\n        print('这是私有方法')\n \n    def foo(self):            # 公共方法\n        print('这是公共方法')\n        self.__foo()\n \nx = Site('菜鸟教程', 'www.runoob.com')\nx.who()        # 正常输出\nx.foo()        # 正常输出\nx.__foo()      # 报错\n\n以上实例执行结果：\n\n类的专有方法：\n__init__ : 构造函数，在生成对象时调用\n__del__ : 析构函数，释放对象时使用\n__repr__ : 打印，转换\n__setitem__ : 按照索引赋值\n__getitem__: 按照索引获取值\n__len__: 获得长度\n__cmp__: 比较运算\n__call__: 函数调用\n__add__: 加运算\n__sub__: 减运算\n__mul__: 乘运算\n__truediv__: 除运算\n__mod__: 求余运算\n__pow__: 乘方\n运算符重载\n\nPython同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：\n\n实例(Python 3.0+)\n#!/usr/bin/python3\n \nclass Vector:\n   def __init__(self, a, b):\n      self.a = a\n      self.b = b\n \n   def __str__(self):\n      return 'Vector (%d, %d)' % (self.a, self.b)\n   \n   def __add__(self,other):\n      return Vector(self.a + other.a, self.b + other.b)\n \nv1 = Vector(2,10)\nv2 = Vector(5,-2)\nprint (v1 + v2)\n\n以上代码执行结果如下所示:\n\nVector(7,8)\n Python3 错误和异常\nPython3 命名空间/作用域 \n16 篇笔记\n 写笔记\n 分类导航\nHTML / CSS\nJavaScript\n服务端\n数据库\n数据分析\n移动端\nXML 教程\nASP.NET\nWeb Service\n开发工具\n网站建设\n\n\nAdvertisement\n反馈/建议\n反馈/建议\n在线实例\n·HTML 实例\n·CSS 实例\n·JavaScript 实例\n·Ajax 实例\n·jQuery 实例\n·XML 实例\n·Java 实例\n字符集&工具\n· HTML 字符集设置\n· HTML ASCII 字符集\n· JS 混淆/加密\n· PNG/JPEG 图片压缩\n· HTML 拾色器\n· JSON 格式化工具\n· 随机数生成器\n最新更新\n· 正则表达式入门教程\n· Python lambda（...\n· Java 注释\n· Bootstrap5 消息...\n· Python 按字母顺...\n· Python 删除字符...\n· git restore 命令\n站点信息\n· 意见反馈\n· 免责声明\n· 关于我们\n· 文章归档\n关注微信\nCopyright © 2013-2023 菜鸟教程  runoob.com All Rights Reserved. 备案号：闽ICP备15012807号-1\n  \nRUNOOB asks for your consent to use your personal data to:\nperm_identity\nPersonalised advertising and content, advertising and content measurement, audience research and services development\ndevices\nStore and/or access information on a device\nexpand_more\nLearn more\n\nYour personal data will be processed and information from your device (cookies, unique identifiers, and other device data) may be stored by, accessed by and shared with 136 TCF vendor(s) and 66 ad partner(s), or used specifically by this site or app.\n\nSome vendors may process your personal data on the basis of legitimate interest, which you can object to by managing your options below. Look for a link at the bottom of this page or in our privacy policy where you can withdraw consent.\n\nConsent\n\nDo not consent\n\nManage options"
}