{
	"title": "Python3 正则表达式 | 菜鸟教程",
	"url": "https://www.runoob.com/python3/python3-reg-expressions.html",
	"html": "菜鸟教程 -- 学的不仅是技术，更是梦想！\n首页 HTML CSS JAVASCRIPT VUE BOOTSTRAP NODEJS PYTHON3 PYTHON2 JAVA C C++ C# GO SQL LINUX JQUERY 本地书签\n Python 3 教程 \nPython3 教程\nPython3 简介\nPython3 环境搭建\nPython3 VScode\nPython3 基础语法\nPython3 基本数据类型\nPython3 数据类型转换\nPython3 解释器\nPython3 注释\nPython3 运算符\nPython3 数字(Number)\nPython3 字符串\nPython3 列表\nPython3 元组\nPython3 字典\nPython3 集合\nPython3 条件控制\nPython3 循环语句\nPython3 编程第一步\nPython3 推导式\nPython3 迭代器与生成器\nPython3 函数\nPython3 lambda\nPython3 数据结构\nPython3 模块\nPython3 输入和输出\nPython3 File\nPython3 OS\nPython3 错误和异常\nPython3 面向对象\nPython3 命名空间/作用域\nPython3 标准库概览\nPython3 实例\nPython 测验\n\n\nPython3 高级教程\n Python3 正则表达式\nPython3 CGI编程\nPython3 MySQL(mysql-connector)\nPython3 MySQL(PyMySQL)\nPython3 网络编程\nPython3 SMTP发送邮件\nPython3 多线程\nPython3 XML 解析\nPython3 JSON\nPython3 日期和时间\nPython3 内置函数\nPython3 MongoDB\nPython3 urllib\nPython uWSGI 安装配置\nPython3 pip\nPython3 operator\nPython math\nPython requests\nPython random\nPython 有用的资源\nPython AI 绘画\nPython statistics\n Python 测验\nPython3 CGI编程 \nPython3 正则表达式\n\n正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。\n\n在 Python 中，使用 re 模块来处理正则表达式。\n\nre 模块提供了一组函数，允许你在字符串中进行模式匹配、搜索和替换操作。\n\nre 模块使 Python 语言拥有完整的正则表达式功能。\n\n本章节主要介绍 Python 中常用的正则表达式处理函数，如果你对正则表达式不了解，可以查看我们的 正则表达式 - 教程。\n\nre.match函数\n\nre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 None。\n\n函数语法：\n\nre.match(pattern, string, flags=0)\n\n函数参数说明：\n\n参数\t描述\npattern\t匹配的正则表达式\nstring\t要匹配的字符串。\nflags\t标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志\n\n匹配成功 re.match 方法返回一个匹配的对象，否则返回 None。\n\n我们可以使用 group(num) 或 groups() 匹配对象函数来获取匹配表达式。\n\n匹配对象方法\t描述\ngroup(num=0)\t匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。\ngroups()\t返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。\n实例\n#!/usr/bin/python\n \nimport re\nprint(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配\nprint(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配\n\n以上实例运行输出结果为：\n\n(0, 3)\nNone\n实例\n#!/usr/bin/python3\nimport re\n \nline = \"Cats are smarter than dogs\"\n# .* 表示任意匹配除换行符（\\n、\\r）之外的任何单个或多个字符\n# (.*?) 表示\"非贪婪\"模式，只保存第一个匹配到的子串\nmatchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)\n \nif matchObj:\n   print (\"matchObj.group() : \", matchObj.group())\n   print (\"matchObj.group(1) : \", matchObj.group(1))\n   print (\"matchObj.group(2) : \", matchObj.group(2))\nelse:\n   print (\"No match!!\")\n\n以上实例执行结果如下：\n\nmatchObj.group() :  Cats are smarter than dogs\nmatchObj.group(1) :  Cats\nmatchObj.group(2) :  smarter\nre.search方法\n\nre.search 扫描整个字符串并返回第一个成功的匹配。\n\n函数语法：\n\nre.search(pattern, string, flags=0)\n\n函数参数说明：\n\n参数\t描述\npattern\t匹配的正则表达式\nstring\t要匹配的字符串。\nflags\t标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志\n\n匹配成功re.search方法返回一个匹配的对象，否则返回None。\n\n我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。\n\n匹配对象方法\t描述\ngroup(num=0)\t匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。\ngroups()\t返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。\n实例\n#!/usr/bin/python3\n \nimport re\n \nprint(re.search('www', 'www.runoob.com').span())  # 在起始位置匹配\nprint(re.search('com', 'www.runoob.com').span())         # 不在起始位置匹配\n\n以上实例运行输出结果为：\n\n(0, 3)\n(11, 14)\n实例\n#!/usr/bin/python3\n \nimport re\n \nline = \"Cats are smarter than dogs\"\n \nsearchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)\n \nif searchObj:\n   print (\"searchObj.group() : \", searchObj.group())\n   print (\"searchObj.group(1) : \", searchObj.group(1))\n   print (\"searchObj.group(2) : \", searchObj.group(2))\nelse:\n   print (\"Nothing found!!\")\n以上实例执行结果如下：\nsearchObj.group() :  Cats are smarter than dogs\nsearchObj.group(1) :  Cats\nsearchObj.group(2) :  smarter\nre.match 与 re.search的区别\n\nre.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。\n\n实例\n#!/usr/bin/python3\n \nimport re\n \nline = \"Cats are smarter than dogs\"\n \nmatchObj = re.match( r'dogs', line, re.M|re.I)\nif matchObj:\n   print (\"match --> matchObj.group() : \", matchObj.group())\nelse:\n   print (\"No match!!\")\n \nmatchObj = re.search( r'dogs', line, re.M|re.I)\nif matchObj:\n   print (\"search --> matchObj.group() : \", matchObj.group())\nelse:\n   print (\"No match!!\")\n以上实例运行结果如下：\nNo match!!\nsearch --> matchObj.group() :  dogs\n检索和替换\n\nPython 的re模块提供了re.sub用于替换字符串中的匹配项。\n\n语法：\n\nre.sub(pattern, repl, string, count=0, flags=0)\n\n参数：\n\npattern : 正则中的模式字符串。\nrepl : 替换的字符串，也可为一个函数。\nstring : 要被查找替换的原始字符串。\ncount : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。\nflags : 编译时用的匹配模式，数字形式。\n\n前三个为必选参数，后两个为可选参数。\n\n实例\n#!/usr/bin/python3\nimport re\n \nphone = \"2004-959-559 # 这是一个电话号码\"\n \n# 删除注释\nnum = re.sub(r'#.*$', \"\", phone)\nprint (\"电话号码 : \", num)\n \n# 移除非数字的内容\nnum = re.sub(r'\\D', \"\", phone)\nprint (\"电话号码 : \", num)\n\n以上实例执行结果如下：\n\n电话号码 :  2004-959-559 \n电话号码 :  2004959559\nrepl 参数是一个函数\n\n以下实例中将字符串中的匹配的数字乘以 2：\n\n实例\n#!/usr/bin/python\n \nimport re\n \n# 将匹配的数字乘以 2\ndef double(matched):\n    value = int(matched.group('value'))\n    return str(value * 2)\n \ns = 'A23G4HFD567'\nprint(re.sub('(?P<value>\\d+)', double, s))\n\n执行输出结果为：\n\nA46G8HFD1134\ncompile 函数\n\ncompile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。\n\n语法格式为：\n\nre.compile(pattern[, flags])\n\n参数：\n\npattern : 一个字符串形式的正则表达式\nflags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：\nre.IGNORECASE 或 re.I - 使匹配对大小写不敏感\nre.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境\nre.MULTILINE 或 re.M - 多行模式，改变 ^ 和 $ 的行为，使它们匹配字符串的每一行的开头和结尾。\nre.DOTALL 或 re.S - 使 . 匹配包括换行符在内的任意字符。\nre.ASCII - 使 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 仅匹配 ASCII 字符。\nre.VERBOSE 或 re.X - 忽略空格和注释，可以更清晰地组织复杂的正则表达式。\n\n这些标志可以单独使用，也可以通过按位或（|）组合使用。例如，re.IGNORECASE | re.MULTILINE 表示同时启用忽略大小写和多行模式。\n\n实例\n实例\n>>>import re\n>>> pattern = re.compile(r'\\d+')                    # 用于匹配至少一个数字\n>>> m = pattern.match('one12twothree34four')        # 查找头部，没有匹配\n>>> print( m )\nNone\n>>> m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配\n>>> print( m )\nNone\n>>> m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配\n>>> print( m )                                        # 返回一个 Match 对象\n<_sre.SRE_Match object at 0x10a42aac0>\n>>> m.group(0)   # 可省略 0\n'12'\n>>> m.start(0)   # 可省略 0\n3\n>>> m.end(0)     # 可省略 0\n5\n>>> m.span(0)    # 可省略 0\n(3, 5)\n\n在上面，当匹配成功时返回一个 Match 对象，其中：\n\ngroup([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；\nstart([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；\nend([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；\nspan([group]) 方法返回 (start(group), end(group))。\n\n再看看一个例子：\n\n实例\n>>>import re\n>>> pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)   # re.I 表示忽略大小写\n>>> m = pattern.match('Hello World Wide Web')\n>>> print( m )                            # 匹配成功，返回一个 Match 对象\n<_sre.SRE_Match object at 0x10bea83e8>\n>>> m.group(0)                            # 返回匹配成功的整个子串\n'Hello World'\n>>> m.span(0)                             # 返回匹配成功的整个子串的索引\n(0, 11)\n>>> m.group(1)                            # 返回第一个分组匹配成功的子串\n'Hello'\n>>> m.span(1)                             # 返回第一个分组匹配成功的子串的索引\n(0, 5)\n>>> m.group(2)                            # 返回第二个分组匹配成功的子串\n'World'\n>>> m.span(2)                             # 返回第二个分组匹配成功的子串索引\n(6, 11)\n>>> m.groups()                            # 等价于 (m.group(1), m.group(2), ...)\n('Hello', 'World')\n>>> m.group(3)                            # 不存在第三个分组\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: no such group\nfindall\n\n在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。\n\n注意： match 和 search 是匹配一次 findall 匹配所有。\n\n语法格式为：\n\nre.findall(pattern, string, flags=0)\n或\npattern.findall(string[, pos[, endpos]])\n\n参数：\n\npattern 匹配模式。\nstring 待匹配的字符串。\npos 可选参数，指定字符串的起始位置，默认为 0。\nendpos 可选参数，指定字符串的结束位置，默认为字符串的长度。\n\n查找字符串中的所有数字：\n\n实例\nimport re\n \nresult1 = re.findall(r'\\d+','runoob 123 google 456')\n \npattern = re.compile(r'\\d+')   # 查找数字\nresult2 = pattern.findall('runoob 123 google 456')\nresult3 = pattern.findall('run88oob123google456', 0, 10)\n \nprint(result1)\nprint(result2)\nprint(result3)\n\n输出结果：\n\n['123', '456']\n['123', '456']\n['88', '12']\n\n多个匹配模式，返回元组列表：\n\n实例\nimport re\n\nresult = re.findall(r'(\\w+)=(\\d+)', 'set width=20 and height=10')\nprint(result)\n\n[('width', '20'), ('height', '10')]\nre.finditer\n\n和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。\n\nre.finditer(pattern, string, flags=0)\n\n参数：\n\n参数\t描述\npattern\t匹配的正则表达式\nstring\t要匹配的字符串。\nflags\t标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志\n实例\nimport re\n \nit = re.finditer(r\"\\d+\",\"12a32bc43jf3\") \nfor match in it: \n    print (match.group() )\n\n输出结果：\n\n12 \n32 \n43 \n3\nre.split\n\nsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：\n\nre.split(pattern, string[, maxsplit=0, flags=0])\n\n参数：\n\n参数\t描述\npattern\t匹配的正则表达式\nstring\t要匹配的字符串。\nmaxsplit\t分割次数，maxsplit=1 分割一次，默认为 0，不限制次数。\nflags\t标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志\n实例\n>>>import re\n>>> re.split('\\W+', 'runoob, runoob, runoob.')\n['runoob', 'runoob', 'runoob', '']\n>>> re.split('(\\W+)', ' runoob, runoob, runoob.') \n['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', '']\n>>> re.split('\\W+', ' runoob, runoob, runoob.', 1) \n['', 'runoob, runoob, runoob.']\n \n>>> re.split('a*', 'hello world')   # 对于一个找不到匹配的字符串而言，split 不会对其作出分割\n['hello world']\n正则表达式对象\nre.RegexObject\n\nre.compile() 返回 RegexObject 对象。\n\nre.MatchObject\n\ngroup() 返回被 RE 匹配的字符串。\n\nstart() 返回匹配开始的位置\nend() 返回匹配结束的位置\nspan() 返回一个元组包含匹配 (开始,结束) 的位置\n正则表达式修饰符 - 可选标志\n\n正则表达式可以包含一些可选标志修饰符来控制匹配的模式。\n\n以下标志可以单独使用，也可以通过按位或（|）组合使用。例如，re.IGNORECASE | re.MULTILINE 表示同时启用忽略大小写和多行模式。\n\n修饰符\t描述\t实例\nre.IGNORECASE 或 re.I\t使匹配对大小写不敏感\t\nimport re\npattern = re.compile(r'apple', flags=re.IGNORECASE)\nresult = pattern.match('Apple')\nprint(result.group())  # 输出: 'Apple'\n\nre.MULTILINE 或 re.M\t多行匹配，影响 ^ 和 $，使它们匹配字符串的每一行的开头和结尾。\t\nimport re\npattern = re.compile(r'^\\d+', flags=re.MULTILINE)\ntext = '123\\n456\\n789'\nresult = pattern.findall(text)\nprint(result)  # 输出: ['123', '456', '789']\n\nre.DOTALL 或 re.S：\t使 . 匹配包括换行符在内的任意字符。\t\nimport re\npattern = re.compile(r'a.b', flags=re.DOTALL)\nresult = pattern.match('a\\nb')\nprint(result.group())  # 输出: 'a\\nb'\n\nre.ASCII\t使 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 仅匹配 ASCII 字符。\t\nimport re\npattern = re.compile(r'\\w+', flags=re.ASCII)\nresult = pattern.match('Hello123')\nprint(result.group())  # 输出: 'Hello123'\n\nre.VERBOSE 或 re.X\t忽略空格和注释，可以更清晰地组织复杂的正则表达式。\t\nimport re\npattern = re.compile(r'''\n    \\d+  # 匹配数字\n    [a-z]+  # 匹配小写字母\n''', flags=re.VERBOSE)\nresult = pattern.match('123abc')\nprint(result.group())  # 输出: '123abc'\n正则表达式模式\n\n模式字符串使用特殊的语法来表示一个正则表达式。\n\n字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。\n\n多数字母和数字前加一个反斜杠时会拥有不同的含义。\n\n标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。\n\n反斜杠本身需要使用反斜杠转义。\n\n由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\\t'，等价于 \\\\t )匹配相应的特殊字符。\n\n下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。\n\n模式\t描述\n^\t匹配字符串的开头\n$\t匹配字符串的末尾。\n.\t匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。\n[...]\t用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'\n[^...]\t不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。\nre*\t匹配0个或多个的表达式。\nre+\t匹配1个或多个的表达式。\nre?\t匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式\nre{ n}\t匹配n个前面表达式。例如，\"o{2}\"不能匹配\"Bob\"中的\"o\"，但是能匹配\"food\"中的两个o。\nre{ n,}\t精确匹配n个前面表达式。例如，\"o{2,}\"不能匹配\"Bob\"中的\"o\"，但能匹配\"foooood\"中的所有o。\"o{1,}\"等价于\"o+\"。\"o{0,}\"则等价于\"o*\"。\nre{ n, m}\t匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式\na| b\t匹配a或b\n(re)\t匹配括号内的表达式，也表示一个组\n(?imx)\t正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。\n(?-imx)\t正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。\n(?: re)\t类似 (...), 但是不表示一个组\n(?imx: re)\t在括号中使用i, m, 或 x 可选标志\n(?-imx: re)\t在括号中不使用i, m, 或 x 可选标志\n(?#...)\t注释.\n(?= re)\t前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。\n(?! re)\t前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。\n(?> re)\t匹配的独立模式，省去回溯。\n\\w\t匹配数字字母下划线\n\\W\t匹配非数字字母下划线\n\\s\t匹配任意空白字符，等价于 [\\t\\n\\r\\f]。\n\\S\t匹配任意非空字符\n\\d\t匹配任意数字，等价于 [0-9]。\n\\D\t匹配任意非数字\n\\A\t匹配字符串开始\n\\Z\t匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。\n\\z\t匹配字符串结束\n\\G\t匹配最后匹配完成的位置。\n\\b\t匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。\n\\B\t匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。\n\\n, \\t, 等。\t匹配一个换行符。匹配一个制表符, 等\n\\1...\\9\t匹配第n个分组的内容。\n\\10\t匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。\n正则表达式实例\n字符匹配\n实例\t描述\npython\t匹配 \"python\".\n字符类\n实例\t描述\n[Pp]ython\t匹配 \"Python\" 或 \"python\"\nrub[ye]\t匹配 \"ruby\" 或 \"rube\"\n[aeiou]\t匹配中括号内的任意一个字母\n[0-9]\t匹配任何数字。类似于 [0123456789]\n[a-z]\t匹配任何小写字母\n[A-Z]\t匹配任何大写字母\n[a-zA-Z0-9]\t匹配任何字母及数字\n[^aeiou]\t除了aeiou字母以外的所有字符\n[^0-9]\t匹配除了数字外的字符\n特殊字符类\n实例\t描述\n.\t匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。\n\\d\t匹配一个数字字符。等价于 [0-9]。\n\\D\t匹配一个非数字字符。等价于 [^0-9]。\n\\s\t匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\n\\S\t匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\\w\t匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。\n\\W\t匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。\n Python 测验\nPython3 CGI编程 \n10 篇笔记\n 写笔记\n 分类导航\nHTML / CSS\nJavaScript\n服务端\n数据库\n数据分析\n移动端\nXML 教程\nASP.NET\nWeb Service\n开发工具\n网站建设\n\n\nAdvertisement\n反馈/建议\n反馈/建议\n在线实例\n·HTML 实例\n·CSS 实例\n·JavaScript 实例\n·Ajax 实例\n·jQuery 实例\n·XML 实例\n·Java 实例\n字符集&工具\n· HTML 字符集设置\n· HTML ASCII 字符集\n· JS 混淆/加密\n· PNG/JPEG 图片压缩\n· HTML 拾色器\n· JSON 格式化工具\n· 随机数生成器\n最新更新\n· 正则表达式入门教程\n· Python lambda（...\n· Java 注释\n· Bootstrap5 消息...\n· Python 按字母顺...\n· Python 删除字符...\n· git restore 命令\n站点信息\n· 意见反馈\n· 免责声明\n· 关于我们\n· 文章归档\n关注微信\nCopyright © 2013-2023 菜鸟教程  runoob.com All Rights Reserved. 备案号：闽ICP备15012807号-1\n  \nRUNOOB asks for your consent to use your personal data to:\nperm_identity\nPersonalised advertising and content, advertising and content measurement, audience research and services development\ndevices\nStore and/or access information on a device\nexpand_more\nLearn more\n\nYour personal data will be processed and information from your device (cookies, unique identifiers, and other device data) may be stored by, accessed by and shared with 136 TCF vendor(s) and 66 ad partner(s), or used specifically by this site or app.\n\nSome vendors may process your personal data on the basis of legitimate interest, which you can object to by managing your options below. Look for a link at the bottom of this page or in our privacy policy where you can withdraw consent.\n\nConsent\n\nDo not consent\n\nManage options"
}