{
	"title": "Python3 模块 | 菜鸟教程",
	"url": "https://www.runoob.com/python3/python3-module.html",
	"html": "菜鸟教程 -- 学的不仅是技术，更是梦想！\n首页 HTML CSS JAVASCRIPT VUE BOOTSTRAP NODEJS PYTHON3 PYTHON2 JAVA C C++ C# GO SQL LINUX JQUERY 本地书签\n Python 3 教程 \nPython3 教程\nPython3 简介\nPython3 环境搭建\nPython3 VScode\nPython3 基础语法\nPython3 基本数据类型\nPython3 数据类型转换\nPython3 解释器\nPython3 注释\nPython3 运算符\nPython3 数字(Number)\nPython3 字符串\nPython3 列表\nPython3 元组\nPython3 字典\nPython3 集合\nPython3 条件控制\nPython3 循环语句\nPython3 编程第一步\nPython3 推导式\nPython3 迭代器与生成器\nPython3 函数\nPython3 lambda\nPython3 数据结构\n Python3 模块\nPython3 输入和输出\nPython3 File\nPython3 OS\nPython3 错误和异常\nPython3 面向对象\nPython3 命名空间/作用域\nPython3 标准库概览\nPython3 实例\nPython 测验\n\n\nPython3 高级教程\nPython3 正则表达式\nPython3 CGI编程\nPython3 MySQL(mysql-connector)\nPython3 MySQL(PyMySQL)\nPython3 网络编程\nPython3 SMTP发送邮件\nPython3 多线程\nPython3 XML 解析\nPython3 JSON\nPython3 日期和时间\nPython3 内置函数\nPython3 MongoDB\nPython3 urllib\nPython uWSGI 安装配置\nPython3 pip\nPython3 operator\nPython math\nPython requests\nPython random\nPython 有用的资源\nPython AI 绘画\nPython statistics\n Python3 数据结构\nPython3 输入和输出 \nPython3 模块\n\n在前面的几个章节中我们基本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。\n\n为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。\n\n模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。\n\n下面是一个使用 python 标准库中模块的例子。\n\n实例(Python 3.0+)\n#!/usr/bin/python3\n# 文件名: using_sys.py\n \nimport sys\n \nprint('命令行参数如下:')\nfor i in sys.argv:\n   print(i)\n \nprint('\\n\\nPython 路径为：', sys.path, '\\n')\n\n执行结果如下所示：\n\n$ python using_sys.py 参数1 参数2\n命令行参数如下:\nusing_sys.py\n参数1\n参数2\n\n\nPython 路径为： ['/root', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages'] \n\n1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。\n2、sys.argv 是一个包含命令行参数的列表。\n3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。\nimport 语句\n\n想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：\n\nimport module1[, module2[,... moduleN]\n\n当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。\n\n搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端：\n\nsupport.py 文件代码\n#!/usr/bin/python3\n# Filename: support.py\n \ndef print_func( par ):\n    print (\"Hello : \", par)\n    return\n\ntest.py 引入 support 模块：\n\ntest.py 文件代码\n#!/usr/bin/python3\n# Filename: test.py\n \n# 导入模块\nimport support\n \n# 现在可以调用模块里包含的函数了\nsupport.print_func(\"Runoob\")\n\n以上实例输出结果：\n\n$ python3 test.py \nHello :  Runoob\n\n下载代码\n\n一个模块只会被导入一次，不管你执行了多少次 import。这样可以防止导入模块被一遍又一遍地执行。\n\n当我们使用 import 语句的时候，Python 解释器是怎样找到对应的文件的呢？\n\n这就涉及到 Python 的搜索路径，搜索路径是由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块。\n\n这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。\n\n搜索路径是在 Python 编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在 sys 模块中的 path 变量，做一个简单的实验，在交互式解释器中，输入以下代码：\n\n>>> import sys\n>>> sys.path\n['', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages']\n>>> \n\nsys.path 输出是一个列表，其中第一项是空串 ''，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。\n\n因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。\n\n了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。\n\n现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下：\n\n实例\n# 斐波那契(fibonacci)数列模块\n \ndef fib(n):    # 定义到 n 的斐波那契数列\n    a, b = 0, 1\n    while b < n:\n        print(b, end=' ')\n        a, b = b, a+b\n    print()\n \ndef fib2(n): # 返回到 n 的斐波那契数列\n    result = []\n    a, b = 0, 1\n    while b < n:\n        result.append(b)\n        a, b = b, a+b\n    return result\n\n然后进入Python解释器，使用下面的命令导入这个模块：\n\n>>> import fibo\n\n这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。\n\n可以使用模块名称来访问函数：\n\n实例\n>>>fibo.fib(1000)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\n\n如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：\n\n>>> fib = fibo.fib\n>>> fib(500)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377\n\n\nfrom … import 语句\n\nPython 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：\n\nfrom modname import name1[, name2[, ... nameN]]\n\n例如，要导入模块 fibo 的 fib 函数，使用如下语句：\n\n>>> from fibo import fib, fib2\n>>> fib(500)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377\n\n这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。\n\n\n\nfrom … import * 语句\n\n把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：\n\nfrom modname import *\n\n这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。\n\n深入模块\n\n模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。\n\n每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。\n\n所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。\n\n从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。\n\n模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。\n\n还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如:\n\n>>> from fibo import fib, fib2\n>>> fib(500)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377\n\n这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。\n\n这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:\n\n>>> from fibo import *\n>>> fib(500)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377\n\n这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。\n\n__name__属性\n\n一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。\n\n#!/usr/bin/python3\n# Filename: using_name.py\n\nif __name__ == '__main__':\n   print('程序自身在运行')\nelse:\n   print('我来自另一模块')\n\n运行输出如下：\n\n$ python using_name.py\n程序自身在运行\n$ python\n>>> import using_name\n我来自另一模块\n>>>\n\n说明： 每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入。\n\n说明：__name__ 与 __main__ 底下是双下划线， _ _ 是这样去掉中间的那个空格。\n\ndir() 函数\n\n内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:\n\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)  \n['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',\n '__package__', '__stderr__', '__stdin__', '__stdout__',\n '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',\n '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',\n 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',\n 'call_tracing', 'callstats', 'copyright', 'displayhook',\n 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',\n 'executable', 'exit', 'flags', 'float_info', 'float_repr_style',\n 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',\n 'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',\n 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount',\n 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',\n 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',\n 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',\n 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',\n 'thread_info', 'version', 'version_info', 'warnoptions']\n\n如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:\n\n>>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir() # 得到一个当前模块中定义的属性列表\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']\n>>> a = 5 # 建立一个新的变量 'a'\n>>> dir()\n['__builtins__', '__doc__', '__name__', 'a', 'sys']\n>>>\n>>> del a # 删除变量名a\n>>>\n>>> dir()\n['__builtins__', '__doc__', '__name__', 'sys']\n>>>\n标准模块\n\nPython 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的\"库参考文档\"）。\n\n有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。\n\n这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。\n\n应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:\n\n>>> import sys\n>>> sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print('Runoob!')\nRunoob!\nC> \n包\n\n包是一种管理 Python 模块命名空间的形式，采用\"点模块名称\"。\n\n比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。\n\n就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。\n\n这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。\n\n不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个\"包\"）。\n\n现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。\n\n并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。\n\n这里给出了一种可能的包结构（在分层的文件系统中）:\n\nsound/                          顶层包\n      __init__.py               初始化 sound 包\n      formats/                  文件格式转换子包\n              __init__.py\n              wavread.py\n              wavwrite.py\n              aiffread.py\n              aiffwrite.py\n              auread.py\n              auwrite.py\n              ...\n      effects/                  声音效果子包\n              __init__.py\n              echo.py\n              surround.py\n              reverse.py\n              ...\n      filters/                  filters 子包\n              __init__.py\n              equalizer.py\n              vocoder.py\n              karaoke.py\n              ...\n\n在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。\n\n目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。\n\n最简单的情况，放一个空的 :file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。\n\n用户可以每次只导入一个包里面的特定模块，比如:\n\nimport sound.effects.echo\n\n这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:\n\nsound.effects.echo.echofilter(input, output, delay=0.7, atten=4)\n\n还有一种导入子模块的方法是:\n\nfrom sound.effects import echo\n\n这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:\n\necho.echofilter(input, output, delay=0.7, atten=4)\n\n还有一种变化就是直接导入一个函数或者变量:\n\nfrom sound.effects.echo import echofilter\n\n同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:\n\nechofilter(input, output, delay=0.7, atten=4)\n\n注意当使用 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。\n\nimport 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。\n\n反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。\n\n从一个包中导入*\n\n如果我们使用 from sound.effects import * 会发生什么呢？\n\nPython 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。\n\n但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。\n\n在 Windows 平台上，我们无法确定一个叫做 ECHO.py 的文件导入为模块是 echo 还是 Echo，或者是 ECHO。\n\n为了解决这个问题，我们只需要提供一个精确包的索引。\n\n导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。\n\n作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了啊。\n\n以下实例在 file:sounds/effects/__init__.py 中包含如下代码:\n\n__all__ = [\"echo\", \"surround\", \"reverse\"]\n\n这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。\n\n如果 __all__ 真的没有定义，那么使用from sound.effects import *这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。\n\n这会把 __init__.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:\n\nimport sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import *\n\n这个例子中，在执行 from...import 前，包 sound.effects 中的 echo 和 surround 模块都被导入到当前的命名空间中了。（当然如果定义了 __all__ 就更没问题了）\n\n通常我们并不主张使用 * 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。\n\n记住，使用 from Package import specific_submodule 这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。\n\n如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包 sound.effects 中的模块 echo，你就要写成 from sound.effects import echo。\n\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\n\n无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是\"__main__\"，一个Python应用程序的主模块，应当总是使用绝对路径引用。\n\n包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。\n\n这个功能并不常用，一般用来扩展包里面的模块。\n\n Python3 数据结构\nPython3 输入和输出 \n5 篇笔记\n 写笔记\n 分类导航\nHTML / CSS\nJavaScript\n服务端\n数据库\n数据分析\n移动端\nXML 教程\nASP.NET\nWeb Service\n开发工具\n网站建设\n\n\nAdvertisement\n反馈/建议\n反馈/建议\n在线实例\n·HTML 实例\n·CSS 实例\n·JavaScript 实例\n·Ajax 实例\n·jQuery 实例\n·XML 实例\n·Java 实例\n字符集&工具\n· HTML 字符集设置\n· HTML ASCII 字符集\n· JS 混淆/加密\n· PNG/JPEG 图片压缩\n· HTML 拾色器\n· JSON 格式化工具\n· 随机数生成器\n最新更新\n· 正则表达式入门教程\n· Python lambda（...\n· Java 注释\n· Bootstrap5 消息...\n· Python 按字母顺...\n· Python 删除字符...\n· git restore 命令\n站点信息\n· 意见反馈\n· 免责声明\n· 关于我们\n· 文章归档\n关注微信\nCopyright © 2013-2023 菜鸟教程  runoob.com All Rights Reserved. 备案号：闽ICP备15012807号-1\n  \nRUNOOB asks for your consent to use your personal data to:\nperm_identity\nPersonalised advertising and content, advertising and content measurement, audience research and services development\ndevices\nStore and/or access information on a device\nexpand_more\nLearn more\n\nYour personal data will be processed and information from your device (cookies, unique identifiers, and other device data) may be stored by, accessed by and shared with 136 TCF vendor(s) and 66 ad partner(s), or used specifically by this site or app.\n\nSome vendors may process your personal data on the basis of legitimate interest, which you can object to by managing your options below. Look for a link at the bottom of this page or in our privacy policy where you can withdraw consent.\n\nConsent\n\nDo not consent\n\nManage options"
}