{
	"title": "Python3 输入和输出 | 菜鸟教程",
	"url": "https://www.runoob.com/python3/python3-inputoutput.html",
	"html": "菜鸟教程 -- 学的不仅是技术，更是梦想！\n首页 HTML CSS JAVASCRIPT VUE BOOTSTRAP NODEJS PYTHON3 PYTHON2 JAVA C C++ C# GO SQL LINUX JQUERY 本地书签\n Python 3 教程 \nPython3 教程\nPython3 简介\nPython3 环境搭建\nPython3 VScode\nPython3 基础语法\nPython3 基本数据类型\nPython3 数据类型转换\nPython3 解释器\nPython3 注释\nPython3 运算符\nPython3 数字(Number)\nPython3 字符串\nPython3 列表\nPython3 元组\nPython3 字典\nPython3 集合\nPython3 条件控制\nPython3 循环语句\nPython3 编程第一步\nPython3 推导式\nPython3 迭代器与生成器\nPython3 函数\nPython3 lambda\nPython3 数据结构\nPython3 模块\n Python3 输入和输出\nPython3 File\nPython3 OS\nPython3 错误和异常\nPython3 面向对象\nPython3 命名空间/作用域\nPython3 标准库概览\nPython3 实例\nPython 测验\n\n\nPython3 高级教程\nPython3 正则表达式\nPython3 CGI编程\nPython3 MySQL(mysql-connector)\nPython3 MySQL(PyMySQL)\nPython3 网络编程\nPython3 SMTP发送邮件\nPython3 多线程\nPython3 XML 解析\nPython3 JSON\nPython3 日期和时间\nPython3 内置函数\nPython3 MongoDB\nPython3 urllib\nPython uWSGI 安装配置\nPython3 pip\nPython3 operator\nPython math\nPython requests\nPython random\nPython 有用的资源\nPython AI 绘画\nPython statistics\n Python3 模块\nPython3 File \nPython3 输入和输出\n\n在前面几个章节中，我们其实已经接触了 Python 的输入输出的功能。本章节我们将具体介绍 Python 的输入输出。\n\n输出格式美化\n\nPython两种输出值的方式: 表达式语句和 print() 函数。\n\n第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。\n\n如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。\n\n如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。\n\nstr()： 函数返回一个用户易读的表达形式。\nrepr()： 产生一个解释器易读的表达形式。\n例如\n>>> s = 'Hello, Runoob'\n>>> str(s)\n'Hello, Runoob'\n>>> repr(s)\n\"'Hello, Runoob'\"\n>>> str(1/7)\n'0.14285714285714285'\n>>> x = 10 * 3.25\n>>> y = 200 * 200\n>>> s = 'x 的值为： ' + repr(x) + ',  y 的值为：' + repr(y) + '...'\n>>> print(s)\nx 的值为： 32.5,  y 的值为：40000...\n>>> #  repr() 函数可以转义字符串中的特殊字符\n... hello = 'hello, runoob\\n'\n>>> hellos = repr(hello)\n>>> print(hellos)\n'hello, runoob\\n'\n>>> # repr() 的参数可以是 Python 的任何对象\n... repr((x, y, ('Google', 'Runoob')))\n\"(32.5, 40000, ('Google', 'Runoob'))\"\n\n\n这里有两种方式输出一个平方与立方的表:\n\n>>> for x in range(1, 11):\n...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n...     # 注意前一行 'end' 的使用\n...     print(repr(x*x*x).rjust(4))\n...\n 1   1    1\n 2   4    8\n 3   9   27\n 4  16   64\n 5  25  125\n 6  36  216\n 7  49  343\n 8  64  512\n 9  81  729\n10 100 1000\n\n>>> for x in range(1, 11):\n...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n...\n 1   1    1\n 2   4    8\n 3   9   27\n 4  16   64\n 5  25  125\n 6  36  216\n 7  49  343\n 8  64  512\n 9  81  729\n10 100 1000\n\n\n注意：在第一个例子中, 每列间的空格由 print() 添加。\n\n这个例子展示了字符串对象的 rjust() 方法, 它可以将字符串靠右, 并在左边填充空格。\n\n还有类似的方法, 如 ljust() 和 center()。 这些方法并不会写任何东西, 它们仅仅返回新的字符串。\n\n另一个方法 zfill(), 它会在数字的左边填充 0，如下所示：\n\n>>> '12'.zfill(5)\n'00012'\n>>> '-3.14'.zfill(7)\n'-003.14'\n>>> '3.14159265359'.zfill(5)\n'3.14159265359'\n\n\nstr.format() 的基本使用如下:\n\n>>> print('{}网址： \"{}!\"'.format('菜鸟教程', 'www.runoob.com'))\n菜鸟教程网址： \"www.runoob.com!\"\n\n\n括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。\n\n在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：\n\n>>> print('{0} 和 {1}'.format('Google', 'Runoob'))\nGoogle 和 Runoob\n>>> print('{1} 和 {0}'.format('Google', 'Runoob'))\nRunoob 和 Google\n\n\n如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。\n\n>>> print('{name}网址： {site}'.format(name='菜鸟教程', site='www.runoob.com'))\n菜鸟教程网址： www.runoob.com\n\n\n位置及关键字参数可以任意的结合:\n\n>>> print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))\n站点列表 Google, Runoob, 和 Taobao。\n\n\n!a (使用 ascii()), !s (使用 str()) 和 !r (使用 repr()) 可以用于在格式化某个值之前对其进行转化:\n\n>>> import math\n>>> print('常量 PI 的值近似为： {}。'.format(math.pi))\n常量 PI 的值近似为： 3.141592653589793。\n>>> print('常量 PI 的值近似为： {!r}。'.format(math.pi))\n常量 PI 的值近似为： 3.141592653589793。\n\n\n可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：\n\n>>> import math\n>>> print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))\n常量 PI 的值近似为 3.142。\n\n\n在 : 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。\n\n>>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}\n>>> for name, number in table.items():\n...     print('{0:10} ==> {1:10d}'.format(name, number))\n...\nGoogle     ==>          1\nRunoob     ==>          2\nTaobao     ==>          3\n\n\n如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。\n\n最简单的就是传入一个字典, 然后使用方括号 [] 来访问键值 :\n\n>>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}\n>>> print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))\nRunoob: 2; Google: 1; Taobao: 3\n\n\n也可以通过在 table 变量前使用 ** 来实现相同的功能：\n\n>>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}\n>>> print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))\nRunoob: 2; Google: 1; Taobao: 3\n\n旧式字符串格式化\n\n% 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf() 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:\n\n>>> import math\n>>> print('常量 PI 的值近似为：%5.3f。' % math.pi)\n常量 PI 的值近似为：3.142。\n\n\n因为 str.format() 是比较新的函数， 大多数的 Python 代码仍然使用 % 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format().\n\n读取键盘输入\n\nPython 提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。\n\n实例\n#!/usr/bin/python3\n\nstr = input(\"请输入：\");\nprint (\"你输入的内容是: \", str)\n\n\n这会产生如下的对应着输入的结果：\n\n请输入：菜鸟教程\n你输入的内容是:  菜鸟教程\n读和写文件\n\nopen() 将会返回一个 file 对象，基本语法格式如下:\n\nopen(filename, mode)\nfilename：包含了你要访问的文件名称的字符串值。\nmode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。\n\n不同模式打开文件的完全列表：\n\n模式\t描述\nr\t以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。\nrb\t以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。\nr+\t打开一个文件用于读写。文件指针将会放在文件的开头。\nrb+\t以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。\nw\t打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\nwb\t以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\nw+\t打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\nwb+\t以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\na\t打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\nab\t以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\na+\t打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。\nab+\t以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。\n\n下图很好的总结了这几种模式：\n\n模式\tr\tr+\tw\tw+\ta\ta+\n读\t+\t+\t\t+\t\t+\n写\t\t+\t+\t+\t+\t+\n创建\t\t\t+\t+\t+\t+\n覆盖\t\t\t+\t+\t\t\n指针在开始\t+\t+\t+\t+\t\t\n指针在结尾\t\t\t\t\t+\t+\n\n以下实例将字符串写入到文件 foo.txt 中：\n\n实例\n#!/usr/bin/python3\n\n# 打开一个文件\nf = open(\"/tmp/foo.txt\", \"w\")\n\nf.write( \"Python 是一个非常好的语言。\\n是的，的确非常好!!\\n\" )\n\n# 关闭打开的文件\nf.close()\n\n第一个参数为要打开的文件名。\n第二个参数描述文件如何使用的字符。 mode 可以是 'r' 如果文件只读, 'w' 只用于写 (如果存在同名文件则将被删除), 和 'a' 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. 'r+' 同时用于读写。 mode 参数是可选的; 'r' 将是默认值。\n\n此时打开文件 foo.txt,显示如下：\n\n$ cat /tmp/foo.txt \nPython 是一个非常好的语言。\n是的，的确非常好!!\n文件对象的方法\n\n本节中剩下的例子假设已经创建了一个称为 f 的文件对象。\n\nf.read()\n\n为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。\n\nsize 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。\n\n以下实例假定文件 foo.txt 已存在（上面实例中已创建）：\n\n实例\n#!/usr/bin/python3\n\n# 打开一个文件\nf = open(\"/tmp/foo.txt\", \"r\")\n\nstr = f.read()\nprint(str)\n\n# 关闭打开的文件\nf.close()\n\n\n执行以上程序，输出结果为：\n\nPython 是一个非常好的语言。\n是的，的确非常好!!\nf.readline()\n\nf.readline() 会从文件中读取单独的一行。换行符为 '\\n'。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。\n\n实例\n#!/usr/bin/python3\n\n# 打开一个文件\nf = open(\"/tmp/foo.txt\", \"r\")\n\nstr = f.readline()\nprint(str)\n\n# 关闭打开的文件\nf.close()\n\n\n执行以上程序，输出结果为：\n\nPython 是一个非常好的语言。\nf.readlines()\n\nf.readlines() 将返回该文件中包含的所有行。\n\n如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。\n\n实例\n#!/usr/bin/python3\n\n# 打开一个文件\nf = open(\"/tmp/foo.txt\", \"r\")\n\nstr = f.readlines()\nprint(str)\n\n# 关闭打开的文件\nf.close()\n\n\n执行以上程序，输出结果为：\n\n['Python 是一个非常好的语言。\\n', '是的，的确非常好!!\\n']\n\n另一种方式是迭代一个文件对象然后读取每行:\n\n实例\n#!/usr/bin/python3\n\n# 打开一个文件\nf = open(\"/tmp/foo.txt\", \"r\")\n\nfor line in f:\n    print(line, end='')\n\n# 关闭打开的文件\nf.close()\n\n\n执行以上程序，输出结果为：\n\nPython 是一个非常好的语言。\n是的，的确非常好!!\n\n这个方法很简单, 但是并没有提供一个很好的控制。 因为两者的处理机制不同, 最好不要混用。\n\nf.write()\n\nf.write(string) 将 string 写入到文件中, 然后返回写入的字符数。\n\n实例\n#!/usr/bin/python3\n\n# 打开一个文件\nf = open(\"/tmp/foo.txt\", \"w\")\n\nnum = f.write( \"Python 是一个非常好的语言。\\n是的，的确非常好!!\\n\" )\nprint(num)\n# 关闭打开的文件\nf.close()\n\n\n执行以上程序，输出结果为：\n\n29\n\n如果要写入一些不是字符串的东西, 那么将需要先进行转换:\n\n实例\n#!/usr/bin/python3\n\n# 打开一个文件\nf = open(\"/tmp/foo1.txt\", \"w\")\n\nvalue = ('www.runoob.com', 14)\ns = str(value)\nf.write(s)\n\n# 关闭打开的文件\nf.close()\n\n\n执行以上程序，打开 foo1.txt 文件：\n\n$ cat /tmp/foo1.txt \n('www.runoob.com', 14)\nf.tell()\n\nf.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。\n\nf.seek()\n\n如果要改变文件指针当前的位置, 可以使用 f.seek(offset, from_what) 函数。\n\nfrom_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：\n\nseek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符\nseek(x,1) ： 表示从当前位置往后移动x个字符\nseek(-x,2)：表示从文件的结尾往前移动x个字符\n\nfrom_what 值为默认为0，即文件开头。下面给出一个完整的例子：\n\n>>> f = open('/tmp/foo.txt', 'rb+')\n>>> f.write(b'0123456789abcdef')\n16\n>>> f.seek(5)     # 移动到文件的第六个字节\n5\n>>> f.read(1)\nb'5'\n>>> f.seek(-3, 2) # 移动到文件的倒数第三字节\n13\n>>> f.read(1)\nb'd'\n\n\nf.close()\n\n在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。\n\n当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。\n\n>>> f.close()\n>>> f.read()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nValueError: I/O operation on closed file\n\n\n当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:\n\n>>> with open('/tmp/foo.txt', 'r') as f:\n...     read_data = f.read()\n>>> f.closed\nTrue\n\n\n文件对象还有其他方法, 如 isatty() 和 trucate(), 但这些通常比较少用。\n\npickle 模块\n\npython的pickle模块实现了基本的数据序列和反序列化。\n\n通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。\n\n通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。\n\n基本接口：\n\npickle.dump(obj, file, [,protocol])\n\n有了 pickle 这个对象, 就能对 file 以读取的形式打开:\n\nx = pickle.load(file)\n\n注解：从 file 中读取一个字符串，并将它重构为原来的python对象。\n\nfile: 类文件对象，有read()和readline()接口。\n\n实例 1\n#!/usr/bin/python3\nimport pickle\n\n# 使用pickle模块将数据对象保存到文件\ndata1 = {'a': [1, 2.0, 3, 4+6j],\n         'b': ('string', u'Unicode string'),\n         'c': None}\n\nselfref_list = [1, 2, 3]\nselfref_list.append(selfref_list)\n\noutput = open('data.pkl', 'wb')\n\n# Pickle dictionary using protocol 0.\npickle.dump(data1, output)\n\n# Pickle the list using the highest protocol available.\npickle.dump(selfref_list, output, -1)\n\noutput.close()\n\n实例 2\n#!/usr/bin/python3\nimport pprint, pickle\n\n#使用pickle模块从文件中重构python对象\npkl_file = open('data.pkl', 'rb')\n\ndata1 = pickle.load(pkl_file)\npprint.pprint(data1)\n\ndata2 = pickle.load(pkl_file)\npprint.pprint(data2)\n\npkl_file.close()\n\n Python3 模块\nPython3 File \n8 篇笔记\n 写笔记\n 分类导航\nHTML / CSS\nJavaScript\n服务端\n数据库\n数据分析\n移动端\nXML 教程\nASP.NET\nWeb Service\n开发工具\n网站建设\n\n\nAdvertisement\n反馈/建议\n反馈/建议\n在线实例\n·HTML 实例\n·CSS 实例\n·JavaScript 实例\n·Ajax 实例\n·jQuery 实例\n·XML 实例\n·Java 实例\n字符集&工具\n· HTML 字符集设置\n· HTML ASCII 字符集\n· JS 混淆/加密\n· PNG/JPEG 图片压缩\n· HTML 拾色器\n· JSON 格式化工具\n· 随机数生成器\n最新更新\n· 正则表达式入门教程\n· Python lambda（...\n· Java 注释\n· Bootstrap5 消息...\n· Python 按字母顺...\n· Python 删除字符...\n· git restore 命令\n站点信息\n· 意见反馈\n· 免责声明\n· 关于我们\n· 文章归档\n关注微信\nCopyright © 2013-2023 菜鸟教程  runoob.com All Rights Reserved. 备案号：闽ICP备15012807号-1\n  \nRUNOOB asks for your consent to use your personal data to:\nperm_identity\nPersonalised advertising and content, advertising and content measurement, audience research and services development\ndevices\nStore and/or access information on a device\nexpand_more\nLearn more\n\nYour personal data will be processed and information from your device (cookies, unique identifiers, and other device data) may be stored by, accessed by and shared with 136 TCF vendor(s) and 66 ad partner(s), or used specifically by this site or app.\n\nSome vendors may process your personal data on the basis of legitimate interest, which you can object to by managing your options below. Look for a link at the bottom of this page or in our privacy policy where you can withdraw consent.\n\nConsent\n\nDo not consent\n\nManage options"
}