{
	"title": "Python3 多线程 | 菜鸟教程",
	"url": "https://www.runoob.com/python3/python3-multithreading.html",
	"html": "菜鸟教程 -- 学的不仅是技术，更是梦想！\n首页 HTML CSS JAVASCRIPT VUE BOOTSTRAP NODEJS PYTHON3 PYTHON2 JAVA C C++ C# GO SQL LINUX JQUERY 本地书签\n Python 3 教程 \nPython3 教程\nPython3 简介\nPython3 环境搭建\nPython3 VScode\nPython3 基础语法\nPython3 基本数据类型\nPython3 数据类型转换\nPython3 解释器\nPython3 注释\nPython3 运算符\nPython3 数字(Number)\nPython3 字符串\nPython3 列表\nPython3 元组\nPython3 字典\nPython3 集合\nPython3 条件控制\nPython3 循环语句\nPython3 编程第一步\nPython3 推导式\nPython3 迭代器与生成器\nPython3 函数\nPython3 lambda\nPython3 数据结构\nPython3 模块\nPython3 输入和输出\nPython3 File\nPython3 OS\nPython3 错误和异常\nPython3 面向对象\nPython3 命名空间/作用域\nPython3 标准库概览\nPython3 实例\nPython 测验\n\n\nPython3 高级教程\nPython3 正则表达式\nPython3 CGI编程\nPython3 MySQL(mysql-connector)\nPython3 MySQL(PyMySQL)\nPython3 网络编程\nPython3 SMTP发送邮件\n Python3 多线程\nPython3 XML 解析\nPython3 JSON\nPython3 日期和时间\nPython3 内置函数\nPython3 MongoDB\nPython3 urllib\nPython uWSGI 安装配置\nPython3 pip\nPython3 operator\nPython math\nPython requests\nPython random\nPython 有用的资源\nPython AI 绘画\nPython statistics\n Python3 SMTP发送邮件\nPython3 XML 解析 \nPython3 多线程\n\n多线程类似于同时执行多个不同程序，多线程运行有如下优点：\n\n使用线程可以把占据长时间的程序中的任务放到后台去处理。\n用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。\n程序的运行速度可能加快。\n在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。\n\n每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n\n每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。\n\n指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。\n\n线程可以被抢占（中断）。\n在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） -- 这就是线程的退让。\n\n线程可以分为:\n\n内核线程：由操作系统内核创建和撤销。\n用户线程：不需要内核支持而在用户程序中实现的线程。\n\nPython3 线程中常用的两个模块为：\n\n_thread\nthreading(推荐使用)\n\nthread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用\"thread\" 模块。为了兼容性，Python3 将 thread 重命名为 \"_thread\"。\n\n\n\n开始学习Python线程\n\nPython中使用线程有两种方式：函数或者用类来包装线程对象。\n\n函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下:\n\n_thread.start_new_thread ( function, args[, kwargs] )\n\n参数说明:\n\nfunction - 线程函数。\nargs - 传递给线程函数的参数,他必须是个tuple类型。\nkwargs - 可选参数。\n实例\n#!/usr/bin/python3\n\nimport _thread\nimport time\n\n# 为线程定义一个函数\ndef print_time( threadName, delay):\n   count = 0\n   while count < 5:\n      time.sleep(delay)\n      count += 1\n      print (\"%s: %s\" % ( threadName, time.ctime(time.time()) ))\n\n# 创建两个线程\ntry:\n   _thread.start_new_thread( print_time, (\"Thread-1\", 2, ) )\n   _thread.start_new_thread( print_time, (\"Thread-2\", 4, ) )\nexcept:\n   print (\"Error: 无法启动线程\")\n\nwhile 1:\n   pass\n\n\n执行以上程序输出结果如下：\n\nThread-1: Wed Jan  5 17:38:08 2022\nThread-2: Wed Jan  5 17:38:10 2022\nThread-1: Wed Jan  5 17:38:10 2022\nThread-1: Wed Jan  5 17:38:12 2022\nThread-2: Wed Jan  5 17:38:14 2022\nThread-1: Wed Jan  5 17:38:14 2022\nThread-1: Wed Jan  5 17:38:16 2022\nThread-2: Wed Jan  5 17:38:18 2022\nThread-2: Wed Jan  5 17:38:22 2022\nThread-2: Wed Jan  5 17:38:26 2022\n\n执行以上程后可以按下 ctrl-c 退出。\n\n线程模块\n\nPython3 通过两个标准库 _thread 和 threading 提供对线程的支持。\n\n_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。\n\nthreading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：\n\nthreading.currentThread(): 返回当前的线程变量。\nthreading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。\nthreading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。\n\n除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:\n\nrun(): 用以表示线程活动的方法。\nstart():启动线程活动。\n\njoin([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。\nisAlive(): 返回线程是否活动的。\ngetName(): 返回线程名。\nsetName(): 设置线程名。\n使用 threading 模块创建线程\n\n我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：\n\n实例\n#!/usr/bin/python3\n\nimport threading\nimport time\n\nexitFlag = 0\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, delay):\n        threading.Thread.__init__(self)\n        self.threadID = threadID\n        self.name = name\n        self.delay = delay\n    def run(self):\n        print (\"开始线程：\" + self.name)\n        print_time(self.name, self.delay, 5)\n        print (\"退出线程：\" + self.name)\n\ndef print_time(threadName, delay, counter):\n    while counter:\n        if exitFlag:\n            threadName.exit()\n        time.sleep(delay)\n        print (\"%s: %s\" % (threadName, time.ctime(time.time())))\n        counter -= 1\n\n# 创建新线程\nthread1 = myThread(1, \"Thread-1\", 1)\nthread2 = myThread(2, \"Thread-2\", 2)\n\n# 开启新线程\nthread1.start()\nthread2.start()\nthread1.join()\nthread2.join()\nprint (\"退出主线程\")\n\n\n以上程序执行结果如下；\n\n开始线程：Thread-1\n开始线程：Thread-2\nThread-1: Wed Jan  5 17:34:54 2022\nThread-2: Wed Jan  5 17:34:55 2022\nThread-1: Wed Jan  5 17:34:55 2022\nThread-1: Wed Jan  5 17:34:56 2022\nThread-2: Wed Jan  5 17:34:57 2022\nThread-1: Wed Jan  5 17:34:57 2022\nThread-1: Wed Jan  5 17:34:58 2022\n退出线程：Thread-1\nThread-2: Wed Jan  5 17:34:59 2022\nThread-2: Wed Jan  5 17:35:01 2022\nThread-2: Wed Jan  5 17:35:03 2022\n退出线程：Thread-2\n退出主线程\n线程同步\n\n如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。\n\n使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：\n\n多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。\n\n考虑这样一种情况：一个列表里所有元素都是0，线程\"set\"从后向前把所有元素改成1，而线程\"print\"负责从前往后读取列表并打印。\n\n那么，可能线程\"set\"开始改的时候，线程\"print\"便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。\n\n锁有两种状态——锁定和未锁定。每当一个线程比如\"set\"要访问共享数据时，必须先获得锁定；如果已经有别的线程比如\"print\"获得锁定了，那么就让线程\"set\"暂停，也就是同步阻塞；等到线程\"print\"访问完毕，释放锁以后，再让线程\"set\"继续。\n\n经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。\n\n实例\n#!/usr/bin/python3\n\nimport threading\nimport time\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, delay):\n        threading.Thread.__init__(self)\n        self.threadID = threadID\n        self.name = name\n        self.delay = delay\n    def run(self):\n        print (\"开启线程： \" + self.name)\n        # 获取锁，用于线程同步\n        threadLock.acquire()\n        print_time(self.name, self.delay, 3)\n        # 释放锁，开启下一个线程\n        threadLock.release()\n\ndef print_time(threadName, delay, counter):\n    while counter:\n        time.sleep(delay)\n        print (\"%s: %s\" % (threadName, time.ctime(time.time())))\n        counter -= 1\n\nthreadLock = threading.Lock()\nthreads = []\n\n# 创建新线程\nthread1 = myThread(1, \"Thread-1\", 1)\nthread2 = myThread(2, \"Thread-2\", 2)\n\n# 开启新线程\nthread1.start()\nthread2.start()\n\n# 添加线程到线程列表\nthreads.append(thread1)\nthreads.append(thread2)\n\n# 等待所有线程完成\nfor t in threads:\n    t.join()\nprint (\"退出主线程\")\n\n\n执行以上程序，输出结果为：\n\n开启线程： Thread-1\n开启线程： Thread-2\nThread-1: Wed Jan  5 17:36:50 2022\nThread-1: Wed Jan  5 17:36:51 2022\nThread-1: Wed Jan  5 17:36:52 2022\nThread-2: Wed Jan  5 17:36:54 2022\nThread-2: Wed Jan  5 17:36:56 2022\nThread-2: Wed Jan  5 17:36:58 2022\n退出主线程\n线程优先级队列（ Queue）\n\nPython 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。\n\n这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。\n\nQueue 模块中的常用方法:\n\nQueue.qsize() 返回队列的大小\nQueue.empty() 如果队列为空，返回True,反之False\nQueue.full() 如果队列满了，返回True,反之False\nQueue.full 与 maxsize 大小对应\nQueue.get([block[, timeout]])获取队列，timeout等待时间\nQueue.get_nowait() 相当Queue.get(False)\nQueue.put(item) 写入队列，timeout等待时间\nQueue.put_nowait(item) 相当Queue.put(item, False)\nQueue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号\nQueue.join() 实际上意味着等到队列为空，再执行别的操作\n实例\n#!/usr/bin/python3\n\nimport queue\nimport threading\nimport time\n\nexitFlag = 0\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, q):\n        threading.Thread.__init__(self)\n        self.threadID = threadID\n        self.name = name\n        self.q = q\n    def run(self):\n        print (\"开启线程：\" + self.name)\n        process_data(self.name, self.q)\n        print (\"退出线程：\" + self.name)\n\ndef process_data(threadName, q):\n    while not exitFlag:\n        queueLock.acquire()\n        if not workQueue.empty():\n            data = q.get()\n            queueLock.release()\n            print (\"%s processing %s\" % (threadName, data))\n        else:\n            queueLock.release()\n        time.sleep(1)\n\nthreadList = [\"Thread-1\", \"Thread-2\", \"Thread-3\"]\nnameList = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"]\nqueueLock = threading.Lock()\nworkQueue = queue.Queue(10)\nthreads = []\nthreadID = 1\n\n# 创建新线程\nfor tName in threadList:\n    thread = myThread(threadID, tName, workQueue)\n    thread.start()\n    threads.append(thread)\n    threadID += 1\n\n# 填充队列\nqueueLock.acquire()\nfor word in nameList:\n    workQueue.put(word)\nqueueLock.release()\n\n# 等待队列清空\nwhile not workQueue.empty():\n    pass\n\n# 通知线程是时候退出\nexitFlag = 1\n\n# 等待所有线程完成\nfor t in threads:\n    t.join()\nprint (\"退出主线程\")\n\n\n以上程序执行结果：\n\n开启线程：Thread-1\n开启线程：Thread-2\n开启线程：Thread-3\nThread-3 processing One\nThread-1 processing Two\nThread-2 processing Three\nThread-3 processing Four\nThread-1 processing Five\n退出线程：Thread-3\n退出线程：Thread-2\n退出线程：Thread-1\n退出主线程\n Python3 SMTP发送邮件\nPython3 XML 解析 \n4 篇笔记\n 写笔记\n 分类导航\nHTML / CSS\nJavaScript\n服务端\n数据库\n数据分析\n移动端\nXML 教程\nASP.NET\nWeb Service\n开发工具\n网站建设\n\n\nAdvertisement\n反馈/建议\n反馈/建议\n在线实例\n·HTML 实例\n·CSS 实例\n·JavaScript 实例\n·Ajax 实例\n·jQuery 实例\n·XML 实例\n·Java 实例\n字符集&工具\n· HTML 字符集设置\n· HTML ASCII 字符集\n· JS 混淆/加密\n· PNG/JPEG 图片压缩\n· HTML 拾色器\n· JSON 格式化工具\n· 随机数生成器\n最新更新\n· 正则表达式入门教程\n· Python lambda（...\n· Java 注释\n· Bootstrap5 消息...\n· Python 按字母顺...\n· Python 删除字符...\n· git restore 命令\n站点信息\n· 意见反馈\n· 免责声明\n· 关于我们\n· 文章归档\n关注微信\nCopyright © 2013-2023 菜鸟教程  runoob.com All Rights Reserved. 备案号：闽ICP备15012807号-1\n  \nRUNOOB asks for your consent to use your personal data to:\nperm_identity\nPersonalised advertising and content, advertising and content measurement, audience research and services development\ndevices\nStore and/or access information on a device\nexpand_more\nLearn more\n\nYour personal data will be processed and information from your device (cookies, unique identifiers, and other device data) may be stored by, accessed by and shared with 136 TCF vendor(s) and 66 ad partner(s), or used specifically by this site or app.\n\nSome vendors may process your personal data on the basis of legitimate interest, which you can object to by managing your options below. Look for a link at the bottom of this page or in our privacy policy where you can withdraw consent.\n\nConsent\n\nDo not consent\n\nManage options"
}