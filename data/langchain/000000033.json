{
	"title": "Tagging | ü¶úÔ∏èüîó Langchain",
	"url": "https://python.langchain.com/docs/use_cases/tagging",
	"html": "Skip to main content\nü¶úÔ∏èüîó LangChain\nDocs\nUse cases\nIntegrations\nGuides\nAPI\nMore\nü¶úÔ∏èüîó\nChat\nSearch\n‚åò\nK\nQA over structured data\nSQL\nRetrieval-augmented generation (RAG)\nInteracting with APIs\nChatbots\nExtraction\nSummarization\nTagging\nWeb scraping\nSynthetic data generation\nGraph querying\nTagging\nTagging\n\nOpen In Colab\n\nUse case‚Äã\n\nTagging means labeling a document with classes such as:\n\nsentiment\nlanguage\nstyle (formal, informal etc.)\ncovered topics\npolitical tendency\n\nOverview‚Äã\n\nTagging has a few components:\n\nfunction: Like extraction, tagging uses functions to specify how the model should tag a document\nschema: defines how we want to tag the document\nQuickstart‚Äã\n\nLet‚Äôs see a very straightforward example of how we can use OpenAI functions for tagging in LangChain.\n\n!pip install langchain openai\n\n# Set env var OPENAI_API_KEY or load from a .env file:\n# import dotenv\n# dotenv.load_dotenv()\n\nfrom langchain.chains import create_tagging_chain, create_tagging_chain_pydantic\nfrom langchain.chat_models import ChatOpenAI\n\n\nWe specify a few properties with their expected type in our schema.\n\n# Schema\nschema = {\n    \"properties\": {\n        \"sentiment\": {\"type\": \"string\"},\n        \"aggressiveness\": {\"type\": \"integer\"},\n        \"language\": {\"type\": \"string\"},\n    }\n}\n\n# LLM\nllm = ChatOpenAI(temperature=0, model=\"gpt-3.5-turbo-0613\")\nchain = create_tagging_chain(schema, llm)\n\ninp = \"Estoy increiblemente contento de haberte conocido! Creo que seremos muy buenos amigos!\"\nchain.run(inp)\n\n{'sentiment': 'positive', 'language': 'Spanish'}\n\ninp = \"Estoy muy enojado con vos! Te voy a dar tu merecido!\"\nchain.run(inp)\n\n{'sentiment': 'enojado', 'aggressiveness': 1, 'language': 'es'}\n\n\nAs we can see in the examples, it correctly interprets what we want.\n\nThe results vary so that we get, for example, sentiments in different languages (‚Äòpositive‚Äô, ‚Äòenojado‚Äô etc.).\n\nWe will see how to control these results in the next section.\n\nFiner control‚Äã\n\nCareful schema definition gives us more control over the model‚Äôs output.\n\nSpecifically, we can define:\n\npossible values for each property\ndescription to make sure that the model understands the property\nrequired properties to be returned\n\nHere is an example of how we can use _enum_, _description_, and _required_ to control for each of the previously mentioned aspects:\n\nschema = {\n    \"properties\": {\n        \"aggressiveness\": {\n            \"type\": \"integer\",\n            \"enum\": [1, 2, 3, 4, 5],\n            \"description\": \"describes how aggressive the statement is, the higher the number the more aggressive\",\n        },\n        \"language\": {\n            \"type\": \"string\",\n            \"enum\": [\"spanish\", \"english\", \"french\", \"german\", \"italian\"],\n        },\n    },\n    \"required\": [\"language\", \"sentiment\", \"aggressiveness\"],\n}\n\nchain = create_tagging_chain(schema, llm)\n\n\nNow the answers are much better!\n\ninp = \"Estoy increiblemente contento de haberte conocido! Creo que seremos muy buenos amigos!\"\nchain.run(inp)\n\n{'aggressiveness': 0, 'language': 'spanish'}\n\ninp = \"Estoy muy enojado con vos! Te voy a dar tu merecido!\"\nchain.run(inp)\n\n{'aggressiveness': 5, 'language': 'spanish'}\n\ninp = \"Weather is ok here, I can go outside without much more than a coat\"\nchain.run(inp)\n\n{'aggressiveness': 0, 'language': 'english'}\n\n\nThe LangSmith trace lets us peek under the hood:\n\nAs with extraction, we call the information_extraction function here on the input string.\nThis OpenAI function extraction information based upon the provided schema.\n\nPydantic‚Äã\n\nWe can also use a Pydantic schema to specify the required properties and types.\n\nWe can also send other arguments, such as enum or description, to each field.\n\nThis lets us specify our schema in the same manner that we would a new class or function in Python with purely Pythonic types.\n\nfrom langchain.pydantic_v1 import BaseModel, Field\n\nclass Tags(BaseModel):\n    sentiment: str = Field(..., enum=[\"happy\", \"neutral\", \"sad\"])\n    aggressiveness: int = Field(\n        ...,\n        description=\"describes how aggressive the statement is, the higher the number the more aggressive\",\n        enum=[1, 2, 3, 4, 5],\n    )\n    language: str = Field(\n        ..., enum=[\"spanish\", \"english\", \"french\", \"german\", \"italian\"]\n    )\n\nchain = create_tagging_chain_pydantic(Tags, llm)\n\ninp = \"Estoy muy enojado con vos! Te voy a dar tu merecido!\"\nres = chain.run(inp)\n\nres\n\nTags(sentiment='sad', aggressiveness=5, language='spanish')\n\nGoing deeper‚Äã\nYou can use the metadata tagger document transformer to extract metadata from a LangChain Document.\nThis covers the same basic functionality as the tagging chain, only applied to a LangChain Document.\nPrevious\nSummarization\nNext\nWeb scraping\nUse case\nOverview\nQuickstart\nFiner control\nPydantic\nGoing deeper\nCommunity\nDiscord\nTwitter\nGitHub\nPython\nJS/TS\nMore\nHomepage\nBlog\nCopyright ¬© 2023 LangChain, Inc."
}