{
	"title": "Chatbots | ðŸ¦œï¸ðŸ”— Langchain",
	"url": "https://python.langchain.com/docs/use_cases/chatbots/",
	"html": "Skip to main content\nðŸ¦œï¸ðŸ”— LangChain\nDocs\nUse cases\nIntegrations\nGuides\nAPI\nMore\nðŸ¦œï¸ðŸ”—\nChat\nSearch\nâŒ˜\nK\nQA over structured data\nSQL\nRetrieval-augmented generation (RAG)\nInteracting with APIs\nChatbots\nExtraction\nSummarization\nTagging\nWeb scraping\nSynthetic data generation\nGraph querying\nChatbots\nChatbots\n\nOpen In Colab\n\nUse caseâ€‹\n\nChatbots are one of the central LLM use-cases. The core features of chatbots are that they can have long-running conversations and have access to information that users want to know about.\n\nAside from basic prompting and LLMs, memory and retrieval are the core components of a chatbot. Memory allows a chatbot to remember past interactions, and retrieval provides a chatbot with up-to-date, domain-specific information.\n\nOverviewâ€‹\n\nThe chat model interface is based around messages rather than raw text. Several components are important to consider for chat:\n\nchat model: See here for a list of chat model integrations and here for documentation on the chat model interface in LangChain. You can use LLMs (see here) for chatbots as well, but chat models have a more conversational tone and natively support a message interface.\nprompt template: Prompt templates make it easy to assemble prompts that combine default messages, user input, chat history, and (optionally) additional retrieved context.\nmemory: See here for in-depth documentation on memory types\nretriever (optional): See here for in-depth documentation on retrieval systems. These are useful if you want to build a chatbot with domain-specific knowledge.\nQuickstartâ€‹\n\nHereâ€™s a quick preview of how we can create chatbot interfaces. First letâ€™s install some dependencies and set the required credentials:\n\n!pip install langchain openai\n\n# Set env var OPENAI_API_KEY or load from a .env file:\n# import dotenv\n# dotenv.load_dotenv()\n\n\nWith a plain chat model, we can get chat completions by passing one or more messages to the model.\n\nThe chat model will respond with a message.\n\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.schema import HumanMessage, SystemMessage\n\nchat = ChatOpenAI()\nchat(\n    [\n        HumanMessage(\n            content=\"Translate this sentence from English to French: I love programming.\"\n        )\n    ]\n)\n\nAIMessage(content=\"J'adore la programmation.\", additional_kwargs={}, example=False)\n\n\nAnd if we pass in a list of messages:\n\nmessages = [\n    SystemMessage(\n        content=\"You are a helpful assistant that translates English to French.\"\n    ),\n    HumanMessage(content=\"I love programming.\"),\n]\nchat(messages)\n\nAIMessage(content=\"J'adore la programmation.\", additional_kwargs={}, example=False)\n\n\nWe can then wrap our chat model in a ConversationChain, which has built-in memory for remembering past user inputs and model outputs.\n\nfrom langchain.chains import ConversationChain\n\nconversation = ConversationChain(llm=chat)\nconversation.run(\"Translate this sentence from English to French: I love programming.\")\n\n'Je adore la programmation.'\n\nconversation.run(\"Translate it to German.\")\n\n'Ich liebe Programmieren.'\n\nMemoryâ€‹\n\nAs we mentioned above, the core component of chatbots is the memory system. One of the simplest and most commonly used forms of memory is ConversationBufferMemory: * This memory allows for storing of messages in a buffer * When called in a chain, it returns all of the messages it has stored\n\nLangChain comes with many other types of memory, too. See here for in-depth documentation on memory types.\n\nFor now letâ€™s take a quick look at ConversationBufferMemory. We can manually add a few chat messages to the memory like so:\n\nfrom langchain.memory import ConversationBufferMemory\n\nmemory = ConversationBufferMemory()\nmemory.chat_memory.add_user_message(\"hi!\")\nmemory.chat_memory.add_ai_message(\"whats up?\")\n\n\nAnd now we can load from our memory. The key method exposed by all Memory classes is load_memory_variables. This takes in any initial chain input and returns a list of memory variables which are added to the chain input.\n\nSince this simple memory type doesnâ€™t actually take into account the chain input when loading memory, we can pass in an empty input for now:\n\nmemory.load_memory_variables({})\n\n{'history': 'Human: hi!\\nAI: whats up?'}\n\n\nWe can also keep a sliding window of the most recent k interactions using ConversationBufferWindowMemory.\n\nfrom langchain.memory import ConversationBufferWindowMemory\n\nmemory = ConversationBufferWindowMemory(k=1)\nmemory.save_context({\"input\": \"hi\"}, {\"output\": \"whats up\"})\nmemory.save_context({\"input\": \"not much you\"}, {\"output\": \"not much\"})\nmemory.load_memory_variables({})\n\n{'history': 'Human: not much you\\nAI: not much'}\n\n\nConversationSummaryMemory is an extension of this theme.\n\nIt creates a summary of the conversation over time.\n\nThis memory is most useful for longer conversations where the full message history would consume many tokens.\n\nfrom langchain.llms import OpenAI\nfrom langchain.memory import ConversationSummaryMemory\n\nllm = OpenAI(temperature=0)\nmemory = ConversationSummaryMemory(llm=llm)\nmemory.save_context({\"input\": \"hi\"}, {\"output\": \"whats up\"})\nmemory.save_context(\n    {\"input\": \"im working on better docs for chatbots\"},\n    {\"output\": \"oh, that sounds like a lot of work\"},\n)\nmemory.save_context(\n    {\"input\": \"yes, but it's worth the effort\"},\n    {\"output\": \"agreed, good docs are important!\"},\n)\n\nmemory.load_memory_variables({})\n\n{'history': '\\nThe human greets the AI, to which the AI responds. The human then mentions they are working on better docs for chatbots, to which the AI responds that it sounds like a lot of work. The human agrees that it is worth the effort, and the AI agrees that good docs are important.'}\n\n\nConversationSummaryBufferMemory extends this a bit further:\n\nIt uses token length rather than number of interactions to determine when to flush interactions.\n\nfrom langchain.memory import ConversationSummaryBufferMemory\n\nmemory = ConversationSummaryBufferMemory(llm=llm, max_token_limit=10)\nmemory.save_context({\"input\": \"hi\"}, {\"output\": \"whats up\"})\nmemory.save_context({\"input\": \"not much you\"}, {\"output\": \"not much\"})\n\nConversationâ€‹\n\nWe can unpack what goes under the hood with ConversationChain.\n\nWe can specify our memory, ConversationSummaryMemory and we can specify the prompt.\n\nfrom langchain.chains import LLMChain\nfrom langchain.prompts import (\n    ChatPromptTemplate,\n    HumanMessagePromptTemplate,\n    MessagesPlaceholder,\n    SystemMessagePromptTemplate,\n)\n\n# LLM\nllm = ChatOpenAI()\n\n# Prompt\nprompt = ChatPromptTemplate(\n    messages=[\n        SystemMessagePromptTemplate.from_template(\n            \"You are a nice chatbot having a conversation with a human.\"\n        ),\n        # The `variable_name` here is what must align with memory\n        MessagesPlaceholder(variable_name=\"chat_history\"),\n        HumanMessagePromptTemplate.from_template(\"{question}\"),\n    ]\n)\n\n# Notice that we `return_messages=True` to fit into the MessagesPlaceholder\n# Notice that `\"chat_history\"` aligns with the MessagesPlaceholder name\nmemory = ConversationBufferMemory(memory_key=\"chat_history\", return_messages=True)\nconversation = LLMChain(llm=llm, prompt=prompt, verbose=True, memory=memory)\n\n# Notice that we just pass in the `question` variables - `chat_history` gets populated by memory\nconversation({\"question\": \"hi\"})\n\n\n\n> Entering new LLMChain chain...\nPrompt after formatting:\nSystem: You are a nice chatbot having a conversation with a human.\nHuman: hi\n\n> Finished chain.\n\n{'question': 'hi',\n 'chat_history': [HumanMessage(content='hi', additional_kwargs={}, example=False),\n  AIMessage(content='Hello! How can I assist you today?', additional_kwargs={}, example=False)],\n 'text': 'Hello! How can I assist you today?'}\n\nconversation(\n    {\"question\": \"Translate this sentence from English to French: I love programming.\"}\n)\n\n\n\n> Entering new LLMChain chain...\nPrompt after formatting:\nSystem: You are a nice chatbot having a conversation with a human.\nHuman: hi\nAI: Hello! How can I assist you today?\nHuman: Translate this sentence from English to French: I love programming.\n\n> Finished chain.\n\n{'question': 'Translate this sentence from English to French: I love programming.',\n 'chat_history': [HumanMessage(content='hi', additional_kwargs={}, example=False),\n  AIMessage(content='Hello! How can I assist you today?', additional_kwargs={}, example=False),\n  HumanMessage(content='Translate this sentence from English to French: I love programming.', additional_kwargs={}, example=False),\n  AIMessage(content='Sure! The translation of \"I love programming\" from English to French is \"J\\'adore programmer.\"', additional_kwargs={}, example=False)],\n 'text': 'Sure! The translation of \"I love programming\" from English to French is \"J\\'adore programmer.\"'}\n\nconversation({\"question\": \"Now translate the sentence to German.\"})\n\n\n\n> Entering new LLMChain chain...\nPrompt after formatting:\nSystem: You are a nice chatbot having a conversation with a human.\nHuman: hi\nAI: Hello! How can I assist you today?\nHuman: Translate this sentence from English to French: I love programming.\nAI: Sure! The translation of \"I love programming\" from English to French is \"J'adore programmer.\"\nHuman: Now translate the sentence to German.\n\n> Finished chain.\n\n{'question': 'Now translate the sentence to German.',\n 'chat_history': [HumanMessage(content='hi', additional_kwargs={}, example=False),\n  AIMessage(content='Hello! How can I assist you today?', additional_kwargs={}, example=False),\n  HumanMessage(content='Translate this sentence from English to French: I love programming.', additional_kwargs={}, example=False),\n  AIMessage(content='Sure! The translation of \"I love programming\" from English to French is \"J\\'adore programmer.\"', additional_kwargs={}, example=False),\n  HumanMessage(content='Now translate the sentence to German.', additional_kwargs={}, example=False),\n  AIMessage(content='Certainly! The translation of \"I love programming\" from English to German is \"Ich liebe das Programmieren.\"', additional_kwargs={}, example=False)],\n 'text': 'Certainly! The translation of \"I love programming\" from English to German is \"Ich liebe das Programmieren.\"'}\n\n\nWe can see the chat history preserved in the prompt using the LangSmith trace.\n\nChat Retrievalâ€‹\n\nNow, suppose we want to chat with documents or some other source of knowledge.\n\nThis is popular use case, combining chat with document retrieval.\n\nIt allows us to chat with specific information that the model was not trained on.\n\n!pip install tiktoken chromadb\n\n\nLoad a blog post.\n\nfrom langchain.document_loaders import WebBaseLoader\n\nloader = WebBaseLoader(\"https://lilianweng.github.io/posts/2023-06-23-agent/\")\ndata = loader.load()\n\n\nSplit and store this in a vector.\n\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=0)\nall_splits = text_splitter.split_documents(data)\n\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain.vectorstores import Chroma\n\nvectorstore = Chroma.from_documents(documents=all_splits, embedding=OpenAIEmbeddings())\n\n\nCreate our memory, as before, butâ€™s letâ€™s use ConversationSummaryMemory.\n\nmemory = ConversationSummaryMemory(\n    llm=llm, memory_key=\"chat_history\", return_messages=True\n)\n\nfrom langchain.chains import ConversationalRetrievalChain\nfrom langchain.chat_models import ChatOpenAI\n\nllm = ChatOpenAI()\nretriever = vectorstore.as_retriever()\nqa = ConversationalRetrievalChain.from_llm(llm, retriever=retriever, memory=memory)\n\nqa(\"How do agents use Task decomposition?\")\n\n{'question': 'How do agents use Task decomposition?',\n 'chat_history': [SystemMessage(content='', additional_kwargs={})],\n 'answer': 'Agents can use task decomposition in several ways:\\n\\n1. Simple prompting: Agents can use Language Model based prompting to break down tasks into subgoals. For example, by providing prompts like \"Steps for XYZ\" or \"What are the subgoals for achieving XYZ?\", the agent can generate a sequence of smaller steps that lead to the completion of the overall task.\\n\\n2. Task-specific instructions: Agents can be given task-specific instructions to guide their planning process. For example, if the task is to write a novel, the agent can be instructed to \"Write a story outline.\" This provides a high-level structure for the task and helps in breaking it down into smaller components.\\n\\n3. Human inputs: Agents can also take inputs from humans to decompose tasks. This can be done through direct communication or by leveraging human expertise. Humans can provide guidance and insights to help the agent break down complex tasks into manageable subgoals.\\n\\nOverall, task decomposition allows agents to break down large tasks into smaller, more manageable subgoals, enabling them to plan and execute complex tasks efficiently.'}\n\nqa(\"What are the various ways to implement memory to support it?\")\n\n{'question': 'What are the various ways to implement memory to support it?',\n 'chat_history': [SystemMessage(content='The human asks how agents use task decomposition. The AI explains that agents can use task decomposition in several ways, including simple prompting, task-specific instructions, and human inputs. Task decomposition allows agents to break down large tasks into smaller, more manageable subgoals, enabling them to plan and execute complex tasks efficiently.', additional_kwargs={})],\n 'answer': 'There are several ways to implement memory to support task decomposition:\\n\\n1. Long-Term Memory Management: This involves storing and organizing information in a long-term memory system. The agent can retrieve past experiences, knowledge, and learned strategies to guide the task decomposition process.\\n\\n2. Internet Access: The agent can use internet access to search for relevant information and gather resources to aid in task decomposition. This allows the agent to access a vast amount of information and utilize it in the decomposition process.\\n\\n3. GPT-3.5 Powered Agents: The agent can delegate simple tasks to GPT-3.5 powered agents. These agents can perform specific tasks or provide assistance in task decomposition, allowing the main agent to focus on higher-level planning and decision-making.\\n\\n4. File Output: The agent can store the results of task decomposition in files or documents. This allows for easy retrieval and reference during the execution of the task.\\n\\nThese memory resources help the agent in organizing and managing information, making informed decisions, and effectively decomposing complex tasks into smaller, manageable subgoals.'}\n\n\nAgain, we can use the LangSmith trace to explore the prompt structure.\n\nGoing deeperâ€‹\nAgents, such as the conversational retrieval agent, can be used for retrieval when necessary while also holding a conversation.\nPrevious\nInteracting with APIs\nNext\nExtraction\nUse case\nOverview\nQuickstart\nMemory\nConversation\nChat Retrieval\nGoing deeper\nCommunity\nDiscord\nTwitter\nGitHub\nPython\nJS/TS\nMore\nHomepage\nBlog\nCopyright Â© 2023 LangChain, Inc."
}